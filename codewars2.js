// Отладка конвертера Цельсия
// Ваш друг едет за границу в Соединенные Штаты, поэтому он написал программу для преобразования Фаренгейта в Цельсий. К сожалению, в его коде есть ошибки.
// Найдите ошибки в коде, чтобы конвертер Цельсия работал правильно.
// Чтобы перевести фаренгейты в градусы Цельсия:
// celsius = (fahrenheit - 32) * (5/9)
// Помните, что обычно температуры в текущих погодных условиях даются целыми числами. Датчики температуры могут сообщать о температуре с более высокой точностью, например, с точностью до десятых. Однако погрешность прибора делает такую точность ненадежной для многих типов датчиков измерения температуры.
// function convertToCelsius(temperature) {
//   const celsius = (temperature - 32) * (5 / 9)
//   return celsius
// }
// function weatherInfo(temp) {
//   const c = convertToCelsius(temp)
//   if (c < 0) return c + ' is freezing temperature'
//   else return c + ' is above freezing temperature'
// }
// console.log(weatherInfo(50))
// console.log(weatherInfo(23))

// Создавая игру, ваш партнер Грег решил создать функцию для проверки того, жив ли пользователь, которая называется checkAlive. К сожалению, Грег допустил несколько ошибок при создании функции.
// checkAlive должнa возвращать true, если здоровье игрока больше 0, или false, если оно равно 0 или ниже.
// Функция получает один параметр здоровья, который всегда будет целым числом от -10 до 10.
// function checkAlive(health) {
//   return health > 0
// }
// console.log(checkAlive(5)) //true

// Напишите функцию, которая будет принимать два параметра: переменную и тип, и проверяйте, соответствует ли тип переменной типу. Возвращает true, если типы совпадают, или false, если нет.
// 42, "number"   --> true
// "42", "number" --> false
// function typeValidation(variable, type) {
//   return typeof variable === type
// }
// console.log(typeValidation(42, 'number')) //true

// Широкоротая лягушка особенно интересуется пищевыми привычками других существ.
// Он просто не может перестать спрашивать существ, которых встречает, что они любят есть. Но затем он встречает аллигатора, который просто ОБОЖАЕТ есть широкоротых лягушек!
// Когда он встречает аллигатора, он делает крошечный рот.
// Ваша цель в этом ката — создать полный метод mouth_size, этот метод принимает один аргумент animal, которое соответствует животному, с которым столкнулась лягушка. Если это alligator (без учета регистра), верните small размер, в противном случае верните wide
// function mouthSize(animal) {
//   return animal.toLowerCase() === 'alligator' ? 'small' : 'wide'
// }
// console.log(mouthSize('toucan'))

// Вам дан массив с положительными числами и неотрицательным числом N. Нужно найти N-ю степень элемента в массиве с индексом N. Если N вне массива, то вернуть -1. Не забывайте, что первый элемент имеет индекс 0.
// Давайте рассмотрим несколько примеров:
// array = [1, 2, 3, 4] and N = 2, then the result is 3^2 == 9;
// array = [1, 2, 3] and N = 3, but N is outside of the array, so the result is -1.
// function index(array, n) {
//   return array[n] ? Math.pow(array[n], n) : -1
// }
// console.log(index([1, 2, 3, 4], 2)) //9

// Простое использование сортировки. Создайте функцию, которая возвращает элементы входного массива/списка, отсортированные в лексикографическом порядке.
// const sortme = names => {
//   return names.sort()
// }
// console.log(sortme(['one', 'two', 'three'])) //["one", "three", "two"]

// Твоя машина старая, легко ломается. Амортизаторы исчезли, и вы думаете, что он может выдержать еще около 15 ударов, прежде чем полностью умрет.
// К сожалению для вас, ваш диск очень ухабистый! Дана строка, показывающая либо ровную дорогу (_), либо неровности (n). Если вы можете благополучно добраться до дома, наткнувшись на 15 ударов или меньше, верните Woohoo!, в противном случае верните Car Dead.
// function bump(x) {
//   return x.replace(/_/gi, '').length < 16 ? 'Woohoo!' : 'Car Dead'
// }
// console.log(bump('__nn_nnnn__n_n___n____nn__nnn')) //"Woohoo!"
// console.log(bump('_nnnnnnn_n__n______nn__nn_nnn')) //"Car Dead"

// Ваша задача — реализовать эти функции на данном языке. Убедитесь, что он не редактирует массив; это вызовет проблемы! Вот шпаргалка:
// | HEAD | <----------- TAIL ------------> |
// [  1,  2,  3,  4,  5,  6,  7,  8,  9,  10]
// | <----------- INIT ------------> | LAST |
// head [x] = x
// tail [x] = []
// init [x] = []
// last [x] = x
// head([1,2,3,4,5]); => 1
// tail([1,2,3,4,5]); => [2,3,4,5]
// const head = arr => arr[0]
// const tail = arr => (arr.length > 1 ? arr.slice(1) : [])
// const init = arr => (arr.length > 1 ? arr.slice(0, arr.length - 1) : [])
// const last = arr => arr.slice(-1)[0]
// console.log(init([1, 2, 3, 4, 5]))
// console.log(init([36]))
// console.log(tail([20, 19, 16, 11, 36]))

// Вам предоставляется словарь/хэш/объект, содержащий несколько языков и результаты вашего теста на данных языках. Верните список языков, на которых ваша тестовая оценка не ниже 60, в порядке убывания результатов.
// Примечание: баллы всегда будут уникальными (поэтому не будет повторяющихся значений).
// {"Java": 10, "Ruby": 80, "Python": 65}    -->  ["Ruby", "Python"]
// {"Hindi": 60, "Dutch" : 93, "Greek": 71}  -->  ["Dutch", "Greek", "Hindi"]
// {"C++": 50, "ASM": 10, "Haskell": 20}     -->  []
// function myLanguages(results) {
//   const arr = []
//   for (let i of Object.entries(results)) {
//     if (i[1] > 59) arr.push(i)
//   }
//   return arr.sort((a, b) => b[1] - a[1]).map(el => el[0])
// }
// console.log(myLanguages({ Java: 10, Ruby: 80, Python: 65 }))
// console.log(myLanguages({ Hindi: 60, Greek: 71, Dutch: 93 }))

// Учитывая строку, состоящую из цифр [0-9], вернуть строку, в которой каждая цифра повторяется количество раз, равное ее значению.
// explode("312")
// should return :
// "333122"
// explode("102269")
// should return :
// "12222666666999999999
function explode(s) {
  return s
}
console.log(explode('312'))
